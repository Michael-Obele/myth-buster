import { json, type RequestEvent } from '@sveltejs/kit';
// @ts-ignore
import { PERPLEXITY_API_KEY } from '$env/static/private';
import { building } from '$app/environment';

const PERPLEXITY_API_URL = 'https://api.perplexity.ai/chat/completions';

const MINI_MYTH_BATCH_SYSTEM_PROMPT = `You are a myth-busting AI that generates and verifies common myths.
Generate exactly 5 distinct, common myth statements.
For each myth, provide:
1. The myth statement itself (string).
2. Its "verdict":
   - Set to \`true\` if the myth statement is factually true.
   - Set to \`false\` if the myth statement is factually false (i.e., it's a misconception).
3. A brief, one to three-sentence explanation for the verdict.

Return your response strictly as a single JSON array containing 5 objects. Each object must have the following structure:
{
  "statement": "The myth statement generated by you.",
  "verdict": boolean,
  "explanation": "A brief explanation of the verdict."
}

Example of the expected JSON array output (containing only 2 for brevity, but you must return 5):
[
  {
    "statement": "Humans only use 10% of their brains.",
    "verdict": false,
    "explanation": "This is a long-standing myth. Neurological studies show that we use virtually all parts of our brain, though not all simultaneously."
  },
  {
    "statement": "Goldfish have a three-second memory.",
    "verdict": false,
    "explanation": "Studies have shown that goldfish can remember things for months, not just a few seconds. They can even be trained to perform tasks."
  }
]
Ensure your response is only the JSON array, without any surrounding text or markdown code blocks.
Do not include any other text or explanations outside of the JSON array.
The array must contain exactly 5 myth objects.`;

type MiniMyth = {
	statement: string;
	verdict: boolean;
	explanation: string;
};

type CachedMiniMythResponse = {
	timestamp: number;
	response: MiniMyth[]; // Caches an array of myths
	expiresAt: number;
};

const miniMythCache: Map<string, CachedMiniMythResponse> = !building ? new Map() : new Map();
const MINI_MYTHS_BATCH_CACHE_KEY = "mini_myths_batch";
const CACHE_EXPIRATION_MS = 24 * 60 * 60 * 1000; // 24 hours

function getCachedMiniMythBatchResponse(key: string): MiniMyth[] | null {
	const now = Date.now();
	const cachedData = miniMythCache.get(key);

	if (!cachedData) {
		return null;
	}

	if (now >= cachedData.expiresAt) {
		miniMythCache.delete(key);
		return null;
	}
	return cachedData.response;
}

function cacheMiniMythBatchResponse(key: string, response: MiniMyth[]): void {
	const now = Date.now();
	miniMythCache.set(key, {
		timestamp: now,
		response,
		expiresAt: now + CACHE_EXPIRATION_MS
	});
}

const mythPool = [
	'Goldfish have a three-second memory.',
	'You will catch a cold if you go out with wet hair.',
	'Cracking your knuckles causes arthritis.',
	'Shaving makes hair grow back thicker and darker.',
	'Bulls get angry when they see the color red.',
	'Reading in dim light ruins your eyesight.',
	'Humans only use 10% of their brains.',
	'Carrots improve your night vision.',
	'Lightning never strikes the same place twice.',
	'Dogs can only see in black and white.',
	'Mount Everest is the tallest mountain on Earth.',
	'Bats are blind.',
	'Different parts of your tongue detect different tastes.',
	'It takes seven years to digest chewing gum.'
];

// The mythPool and getRandomMyths are no longer needed as the API will generate them.
// const mythStatementsToVerify = getRandomMyths(5); // No longer needed

async function fetchAndVerifyRandomMythsBatch(apiKey: string): Promise<MiniMyth[] | null> {
	const cachedResponse = getCachedMiniMythBatchResponse(MINI_MYTHS_BATCH_CACHE_KEY);

	if (cachedResponse) {
		console.log(`Using cached response for mini-myth batch.`);
		return cachedResponse;
	}

	const payload = {
		model: 'sonar', // Using a capable model like sonar is good for generation tasks
		messages: [
			{ role: 'system', content: MINI_MYTH_BATCH_SYSTEM_PROMPT },
			// User prompt can be minimal as the system prompt is very detailed
			{ role: 'user', content: "Please generate 5 random myths with their verifications as per the system prompt instructions." }
		]
	};

	console.log("Fetching new batch of random myths from Perplexity API...");

	try {
		const resp = await fetch(PERPLEXITY_API_URL, {
			method: 'POST',
			headers: {
				'Content-Type': 'application/json',
				Authorization: `Bearer ${apiKey}`
			},
			body: JSON.stringify(payload)
		});

		if (!resp.ok) {
			console.error(
				`Perplexity API error for mini-myth batch: ${resp.status} ${resp.statusText}`
			);
			// Try to read error body for more details
			try {
				const errorBody = await resp.json();
				console.error('Perplexity API error body:', errorBody);
			} catch (e) {
				console.error('Could not parse Perplexity API error body.');
			}
			return null; // Or throw an error to be caught by the caller
		}

		const apiResult = await resp.json();
		const content = apiResult.choices?.[0]?.message?.content;

		if (content) {
			try {
				// The prompt asks for a raw JSON array.
				const parsedMyths: any[] = JSON.parse(content);

				// Validate the structure of the response
				if (
					Array.isArray(parsedMyths) &&
					parsedMyths.length === 5 && // Expecting exactly 5 myths
					parsedMyths.every(
						(myth) =>
							typeof myth.statement === 'string' &&
							typeof myth.verdict === 'boolean' &&
							typeof myth.explanation === 'string'
					)
				) {
					const validatedMyths: MiniMyth[] = parsedMyths;
					cacheMiniMythBatchResponse(MINI_MYTHS_BATCH_CACHE_KEY, validatedMyths);
					console.log("Successfully fetched and parsed new myth batch.");
					return validatedMyths;
				} else {
					console.error(
						`Invalid JSON array structure or content from Perplexity API for myth batch:`,
						parsedMyths
					);
					return null;
				}
			} catch (e) {
				console.error(
					`Failed to parse JSON response from Perplexity API for myth batch:`,
					content,
					e
				);
				// Fallback for markdown-wrapped JSON array (less likely with new prompt but good to have)
				const jsonMatch = content.match(/```json\n([\s\S]*?)\n```/);
				if (jsonMatch && jsonMatch[1]) {
					try {
						const parsedMythsFallback: any[] = JSON.parse(jsonMatch[1]);
						if (
							Array.isArray(parsedMythsFallback) &&
							parsedMythsFallback.length === 5 &&
							parsedMythsFallback.every(
								(myth) =>
									typeof myth.statement === 'string' &&
									typeof myth.verdict === 'boolean' &&
									typeof myth.explanation === 'string'
							)
						) {
							const validatedMythsFallback: MiniMyth[] = parsedMythsFallback;
							cacheMiniMythBatchResponse(MINI_MYTHS_BATCH_CACHE_KEY, validatedMythsFallback);
							console.log("Successfully fetched and parsed new myth batch from fallback.");
							return validatedMythsFallback;
						}
					} catch (e2) {
						console.error(
							`Failed to parse fallback JSON from markdown for myth batch:`,
							e2
						);
					}
				}
				return null;
			}
		}
		console.error(`No content received from Perplexity API for myth batch.`);
		return null;
	} catch (error) {
		console.error(`Failed to fetch random myths batch:`, error);
		return null;
	}
}

export async function GET({}: RequestEvent) {
	const apiKey = PERPLEXITY_API_KEY;

	if (!apiKey) {
		console.error('Missing Perplexity API key for /api/minimyths route.');
		return json({ error: 'Server configuration error: API key is missing.' }, { status: 500 });
	}

	const mythBatch = await fetchAndVerifyRandomMythsBatch(apiKey);

	if (mythBatch && mythBatch.length > 0) {
		return json(mythBatch);
	} else {
		// This could happen if API call fails or returns invalid/empty data.
		return json(
			{
				error:
					'Failed to fetch any myth data. The API might be temporarily unavailable, misconfigured, or returned an unexpected format.'
			},
			{ status: 503 } // Service Unavailable
		);
	}
}
