## Revised Architectural Plan for Rate Limiting in Myth-Buster

### 1. Rate Limiting Strategy: Sliding Window Log with Database Storage

The recommended rate limiting algorithm remains the **Sliding Window Log**, but with a significant change in storage mechanism to use the application's database.

**Justification:**
*   **Accuracy and Fairness:** The Sliding Window Log continues to offer accurate and fair rate limiting by tracking individual request timestamps over a rolling period, preventing "burstiness" issues.
*   **Simplified Infrastructure (Database-centric):** By leveraging the existing database (Prisma) for rate limit state storage, the need for an additional Redis instance is removed, simplifying the deployment and maintenance overhead.
*   **Adaptation for Authenticated vs. Unauthenticated:** This strategy allows for distinct handling of user types, using `userId` for logged-in users and a `Visitor ID` generated by `fingerprint.js` for unauthenticated access.

**Considerations for Database Storage:**
While simplifying infrastructure, using a database for rate limiting can introduce performance bottlenecks under high load due to increased I/O operations and potential locking. Careful optimization (e.g., proper indexing on `userId`/`visitorId` and `timestamp` columns) and monitoring will be crucial.

### 2. Scope of Application

Rate limits will be applied to the following parts of the application, prioritizing resource-intensive and sensitive endpoints:

*   **`/api/minimyths`**: This endpoint likely makes calls to external APIs (e.g., Perplexity). Rate limiting is critical to:
    *   Control costs associated with third-party API usage.
    *   Adhere to external API rate limits.
    *   Prevent excessive load on the external service.
*   **`/api/community/signup`**: This endpoint involves database writes. Rate limiting will mitigate:
    *   Spam sign-ups.
    *   Excessive database write operations.
*   **Authentication Endpoints (`/signin`, `/signup`)**: To protect against brute-force attacks and account enumeration:
    *   Rate limit login attempts.
    *   Rate limit new user registrations.
*   **All other `/api/*` routes**: A baseline rate limit will be applied to all other API endpoints to provide general protection against DoS attacks and ensure overall system stability. More specific limits can be configured for individual routes based on their resource consumption.

### 3. Technical Implementation Details

*   **Technologies/Libraries:**
    *   **Prisma & PostgreSQL (or current database):** For storing rate limit records. A new model, e.g., `RateLimitRecord`, will be added to `prisma/schema.prisma`.
    *   **`fingerprint.js`:** For generating a unique `Visitor ID` for unauthenticated users. This will likely involve a client-side script that passes the `Visitor ID` to the backend, or the backend generating it based on client-side headers.
    *   **Lucia Auth:** The existing authentication system for managing user sessions and integrating Google OAuth.
    *   **Custom SvelteKit Hook/Middleware:** A custom implementation within `src/hooks.server.ts` will manage the rate limiting logic, leveraging database storage.

*   **Integration into SvelteKit Backend (`src/hooks.server.ts`):**
    *   The `handle` function in `src/hooks.server.ts` will be extended to:
        1.  **Identify Client:**
            *   If `event.locals.user` is present, use `user.id` as the identifier.
            *   If `event.locals.user` is `null`, attempt to retrieve a `Visitor ID` from the request (e.g., from a custom header `X-Visitor-ID` set by `fingerprint.js` on the frontend, or by generating it based on `event.getClientAddress()` and user-agent string and storing it in a cookie). This `Visitor ID` will be the identifier for unauthenticated requests.
        2.  **Database Query for Rate Limit:** Query the `RateLimitRecord` table to fetch timestamps for the identified client within the current sliding window.
        3.  **Apply Sliding Window Logic:**
            *   Filter out timestamps older than the configured window.
            *   Check if the number of remaining timestamps exceeds the limit.
            *   If exceeded, return a `429 Too Many Requests` response.
        4.  **Record Request:** If within limits, record the current request timestamp in the `RateLimitRecord` table for the identified client.
        5.  **Proceed:** Allow the request to proceed to the appropriate route handler.
    *   Route-specific limits will be managed within the hook by inspecting `event.url.pathname` and applying different rate limit configurations based on the matched route.

*   **Rate Limit State Storage and Management (Database):**
    *   A new Prisma model `RateLimitRecord` will be defined in `prisma/schema.prisma` to store rate limit data.
        ```prisma
        model RateLimitRecord {
          id        String   @id @default(cuid())
          userId    String?
          visitorId String?
          endpoint  String
          timestamp DateTime @default(now())

          @@index([userId, timestamp])
          @@index([visitorId, timestamp])
        }
        ```
    *   For each request, a new `RateLimitRecord` will be created.
    *   Cleanup of old records will be handled by a periodic background job or optimized database queries that only consider records within the current window.

*   **Handling Different User Types:**
    *   **Unauthenticated Users:** Rate limited by their `Visitor ID` generated by `fingerprint.js`. This ID will be persisted in the database.
    *   **Authenticated Users:** Rate limited by their unique `user.id`.
    *   **Premium/Free Users:** The `event.locals.user` object will continue to be used to determine user tiers, allowing different rate limits to be applied based on subscription status.

### 4. Error Handling and User Feedback

When a rate limit is breached, the API will communicate this clearly to the client:

*   **HTTP Status Code:** `429 Too Many Requests`.
*   **Response Headers:**
    *   `Retry-After`: (Required) Integer, indicating the number of seconds the user should wait before making another request. Dynamically calculated.
    *   `X-RateLimit-Limit`: (Recommended) The maximum number of requests allowed within the current window.
    *   `X-RateLimit-Remaining`: (Recommended) The number of requests remaining in the current window (will be 0 on breach).
    *   `X-RateLimit-Reset`: (Recommended) The timestamp (in UTC epoch seconds) when the current rate limit window resets.
*   **Response Body:** A JSON object providing a user-friendly error message.
    ```json
    {
      "error": "Too many requests. You have exceeded your request limit. Please try again after X seconds."
    }
    ```

### 5. Configuration and Management

*   **Parameter Configuration:**
    *   **Environment Variables:** Global rate limit parameters and sensitive API keys will be stored in `.env` files.
    *   **Dedicated Configuration Module (`src/lib/server/rateLimitConfig.ts`):** This module will define an object containing specific rate limit rules for different routes and user tiers. Example structure:
        ```typescript
        export const rateLimitConfig = {
          default: {
            windowMs: 60 * 1000, // 1 minute
            maxRequests: 60,     // 60 requests per minute
          },
          '/api/minimyths': {
            windowMs: 5 * 60 * 1000, // 5 minutes
            maxRequests: {
              authenticated: 100,
              unauthenticated: 10,
              premium: 500,
            },
          },
          '/api/community/signup': {
            windowMs: 1 * 60 * 1000, // 1 minute
            maxRequests: 5,
          },
          '/signin': {
            windowMs: 5 * 60 * 1000, // 5 minutes
            maxRequests: 5, // 5 attempts per 5 minutes per IP/user
          },
          // ... other routes
        };
        ```
*   **Monitoring and Alerting:**
    *   Integrate with existing monitoring solutions to track rate limit hits and breaches.
    *   Set up alerts for sustained high rates of `429` responses, indicating potential attacks or misconfigured limits.

### 6. Google OAuth Integration

*   **Leveraging Lucia Auth:** The existing Lucia Auth setup will be extended to support Google OAuth.
*   **Setup:**
    1.  Obtain Google OAuth credentials (`client_id`, `client_secret`) from Google Cloud Console.
    2.  Store credentials securely in environment variables.
    3.  Implement Lucia's `Google` adapter.
*   **Flow:**
    *   Initiate OAuth: A new endpoint (e.g., `src/routes/auth/google/+server.ts`) will redirect users to Google for authentication.
    *   Callback Handling: Another endpoint (e.g., `src/routes/auth/google/callback/+server.ts`) will handle the callback from Google, verify the token, and manage user sessions via Lucia.
*   **User Provisioning:**
    *   If a user successfully authenticates with Google but does not exist in the database, a new user record will be created and linked to their Google ID.
    *   If the user already exists, their session will be established.
*   **Migration Plan:** A future phase will involve a strategy to migrate existing username/password users to Google OAuth, potentially by allowing them to link their Google accounts.

### 7. Global Rules Directory

*   A new directory `kilo_code_rules` will be created at the project root (`/home/node/Documents/GitHub/myth-buster/kilo_code_rules`).
*   This directory will house markdown files or other configuration files that define global rules, coding standards, architectural guidelines, or other project-wide conventions.

### 8. Documentation Strategy

When seeking documentation, the following priority will be observed:

1.  **Svelte-LLM (`svelte-llm`)**: For Svelte 5 and SvelteKit documentation. Use `list_sections` to discover available content and `get_documentation` to retrieve specific sections.
2.  **Context7 (`github.com/upstash/context7-mcp`)**: If `svelte-llm` fails, or for documentation on other libraries (e.g., Shadcn-Svelte), `context7` will be used. This involves `resolve-library-id` to get the correct library ID, then `get-library-docs` to fetch the documentation.
3.  **Local Files (`src/lib/components/ui`)**: For understanding the implementation and usage of existing Shadcn-Svelte components, direct file reading from `src/lib/components/ui` will be prioritized using `read_file`.

### Mermaid Diagram: Revised Rate Limiting Flow

```mermaid
graph TD
    A[Client Request] --> B{SvelteKit handle hook}
    B --> C{Get Client IP / Fingerprint.js Visitor ID}
    C --> D{Check if Authenticated?}

    D -- No --> E[Use Fingerprint.js Visitor ID as identifier]
    D -- Yes --> F[Use User ID as identifier]

    E --> G{Rate Limiter (Sliding Window Log)}
    F --> G

    G -- Request within limit --> H{Allow Request}
    H --> I[Process API Endpoint]
    I --> J[Return API Response]

    G -- Request exceeds limit --> K{Block Request}
    K --> L[Return 429 Too Many Requests]
    L --> M[Include Retry-After, X-RateLimit-* headers]

    subgraph Database
        N[Store request timestamps in RateLimitRecords table]
    end
    G --- N